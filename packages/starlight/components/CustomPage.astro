---
// Important that this is the first import so it can override cascade layers order.
import 'virtual:starlight/user-css';

// Starlight nested cascade layers definitions which specify the default order of internal layers.
import '../style/layers.css';

// Built-in CSS styles.
import '../style/props.css';
import '../style/reset.css';
import '../style/asides.css';
import '../style/util.css';
import 'virtual:starlight/optional-css';

import Banner from 'virtual:starlight/components/Banner';
import ContentPanel from 'virtual:starlight/components/ContentPanel';
import FallbackContentNotice from 'virtual:starlight/components/FallbackContentNotice';
import DraftContentNotice from 'virtual:starlight/components/DraftContentNotice';
import Footer from 'virtual:starlight/components/Footer';
import Head from 'virtual:starlight/components/Head';
import Header from 'virtual:starlight/components/Header';
import Hero from 'virtual:starlight/components/Hero';
import MarkdownContent from 'virtual:starlight/components/MarkdownContent';
import PageFrame from 'virtual:starlight/components/PageFrame';
import PageSidebar from 'virtual:starlight/components/PageSidebar';
import PageTitle from 'virtual:starlight/components/PageTitle';
import Sidebar from 'virtual:starlight/components/Sidebar';
import SkipLink from 'virtual:starlight/components/SkipLink';
import ThemeProvider from 'virtual:starlight/components/ThemeProvider';
import TwoColumnContent from 'virtual:starlight/components/TwoColumnContent';

import { Steps, Code, FileTree } from '../components';

import printHref from '../style/print.css?url&no-inline';

const { starlightRoute } = Astro.locals;
const blocks = starlightRoute.entry.data?.blocks ?? [];

const pagefindEnabled =
	starlightRoute.entry.slug !== '404' &&
	!starlightRoute.entry.slug.endsWith('/404') &&
	starlightRoute.entry.data.pagefind !== false;

const htmlDataAttributes: DOMStringMap = { 'data-theme': 'dark' };
if (Boolean(starlightRoute.toc)) htmlDataAttributes['data-has-toc'] = '';
if (starlightRoute.hasSidebar) htmlDataAttributes['data-has-sidebar'] = '';
if (Boolean(starlightRoute.entry.data.hero)) htmlDataAttributes['data-has-hero'] = '';

const mainDataAttributes: DOMStringMap = {};
if (pagefindEnabled) mainDataAttributes['data-pagefind-body'] = '';

import { RenderTree } from '../src/lib/renderTree.tsx';
import { parseIndentedTree } from '../src/lib/parseIndentedTree.ts';
import PreactMarkdown from '../src/lib/PreactMarkdown.tsx';
import AstroMarkdown from '../src/lib/AstroMarkdown.astro';
// function parseIndentedTree(treeString: string): any[] {
// 	const lines = treeString.trim().split('\n');

// 	const root: any[] = [];
// 	const stack: { level: number; children: any[] }[] = [{ level: -1, children: root }];

// 	for (let line of lines) {
// 		const match = line.match(/^(\s*)-\s+(.*)/);
// 		if (!match) continue;

// 		const indent = match[1].length;
// 		const name = match[2];

// 		const node: any = name.endsWith('/') ? { name, children: [] } : name;

// 		while (stack.length > 0 && indent <= stack[stack.length - 1].level) {
// 			stack.pop();
// 		}

// 		const parent = stack[stack.length - 1].children;
// 		parent.push(node);

// 		if (typeof node === 'object') {
// 			stack.push({ level: indent, children: node.children });
// 		}
// 	}

// 	return root;
// }

// function renderTree(tree) {
// 	return tree.map((item) => {
// 		if (typeof item === 'string') {
// 			return <li>{item}</li>;
// 		}

// 		if (typeof item === 'object' && item.name && Array.isArray(item.children)) {
// 			return (
// 				<li>
// 					{item.name}
// 					<ul>{renderTree(item.children)}</ul>
// 				</li>
// 			);
// 		}

// 		return null;
// 	});
// }

function debugIndentation(treeString: string) {
	const lines = treeString.split('\n');

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		const match = line.match(/^(\s*)-\s+(.*)/);
		if (!match) {
			console.log(`Line ${i + 1}: No match - "${line}"`);
			continue;
		}
		const rawIndent = match[1];
		const name = match[2];

		// Count spaces after converting tabs to spaces (2 spaces per tab)
		const indentSpaces = rawIndent.replace(/\t/g, '  ').length;
		const indentLevel = indentSpaces / 2;

		console.log(
			`Line ${i + 1}: indentSpaces=${indentSpaces} indentLevel=${indentLevel} name="${name}"`
		);
	}
}

function indentToMarkdownList(treeString: string): string {
	const lines = treeString.trim().split('\n');
	return lines
		.map((line) => {
			const match = line.match(/^(\s*)-\s+(.*)/);
			if (!match) return '';
			const indent = match[1].length;
			const content = match[2];
			const dashes = '  '.repeat(indent / 2);
			return `${dashes}- ${content}`;
		})
		.join('\n');
}
---

<html lang={starlightRoute.lang} dir={starlightRoute.dir} {...htmlDataAttributes}>
	<head>
		<Head />
		<style>
			html:not([data-has-toc]) {
				--sl-mobile-toc-height: 0rem;
			}
			html:not([data-has-sidebar]) {
				--sl-content-width: 67.5rem;
			}
			/* Add scroll padding to ensure anchor headings aren't obscured by nav */
			html {
				/* Additional padding is needed to account for the mobile TOC */
				scroll-padding-top: calc(1.5rem + var(--sl-nav-height) + var(--sl-mobile-toc-height));
			}
			main {
				padding-bottom: 3vh;
			}
			@media (min-width: 50em) {
				[data-has-sidebar] {
					--sl-content-inline-start: var(--sl-sidebar-width);
				}
			}
			@media (min-width: 72em) {
				html {
					scroll-padding-top: calc(1.5rem + var(--sl-nav-height));
				}
			}
		</style>
		<ThemeProvider />
		<link rel="stylesheet" href={printHref} media="print" />
	</head>
	<body>
		<SkipLink />
		<PageFrame>
			<Header slot="header" />
			{starlightRoute.hasSidebar && <Sidebar slot="sidebar" />}
			<script src="./SidebarPersistState"></script>
			<TwoColumnContent>
				<PageSidebar slot="right-sidebar" />
				<main
					{...mainDataAttributes}
					lang={starlightRoute.entryMeta.lang}
					dir={starlightRoute.entryMeta.dir}
				>
					{/* TODO: Revisit how this logic flows. */}
					<Banner />
					{
						starlightRoute.entry.data.hero ? (
							<ContentPanel>
								<Hero />
								<MarkdownContent>
									<slot />
								</MarkdownContent>
								<Footer />
							</ContentPanel>
						) : (
							<>
								<ContentPanel>
									<PageTitle />
									{starlightRoute.entry.data.draft && <DraftContentNotice />}
									{starlightRoute.isFallback && <FallbackContentNotice />}
								</ContentPanel>
								<ContentPanel>
									{starlightRoute.entry.data.blocks ? (
										starlightRoute.entry.data.blocks.map((block) => {
											switch (block.type) {
												case 'rte':
													return (
														<MarkdownContent>
															<PreactMarkdown client:load content={block.content} />
															<AstroMarkdown content={block.content} />
														</MarkdownContent>
													);

												case 'code':
													// Only render Code if code is a non-empty string
													return block.code?.trim() ? (
														<Code code={block.code} lang={block.lang} title={block.title} />
													) : null;

												case 'steps':
													return (
														<Steps title={block.title || 'Steps'}>
															<ol>
																{block.steps.map((step) => (
																	<li>
																		<h4>{step.title}</h4>
																		<p>{step.content}</p>
																		{/* Only render Code if it exists */}
																		{step.code?.trim() && (
																			<Code code={step.code} lang={step.lang} />
																		)}
																		{/* Render filetree if present */}
																		{step.filetree && (
																			<FileTree title={step.filetree.title}>
																				<RenderTree tree={parseIndentedTree(step.filetree.tree)} />
																			</FileTree>
																		)}
																	</li>
																))}
															</ol>
														</Steps>
													);

												case 'filetree':
													return (
														<FileTree title={block.title}>
															<RenderTree tree={parseIndentedTree(block.tree)} />
														</FileTree>
													);

												default:
													return null;
											}
										})
									) : (
										<MarkdownContent>
											<slot />
										</MarkdownContent>
									)}
									<Footer />
								</ContentPanel>
							</>
						)
					}
				</main>
			</TwoColumnContent>
		</PageFrame>
	</body>
</html>
